   ┌────────────┐
   │   Client   │
   └─────┬──────┘
         │
         │ 1. Login (POST /login)
         │   — sends email & password
         ▼
   ┌──────────────┐
   │   Backend    │
   └──────────────┘
         │
         │ ✔ Authenticates credentials
         │ ✔ Generates:
         │    - Access Token (15 min)
         │    - Refresh Token (7 days)
         │ ✔ Stores refreshToken in array/db
         ▼
   ┌────────────┐
   │   Client   │
   └────┬───────┘
        │
        │ 2. Stores:
        │    🍪 accessToken (httpOnly cookie)
        │    🍪 refreshToken (httpOnly cookie)
        │
        ▼

===== Normal API Usage =====
   ┌────────────┐
   │   Client   │
   └────┬───────┘
        │
        │ 3. Makes request to protected route
        │    (GET /profile)
        ▼
   ┌──────────────┐
   │   Backend    │
   └────┬─────────┘
        │
        │ ✔ Reads accessToken from cookie
        │ ✔ Verifies it:
        │    - If valid → allow access
        │    - If expired → return 401
        ▼

===== Access Token Expired =====
   ┌────────────┐
   │   Client   │
   └────┬───────┘
        │
        │ 4. Gets 401 → calls:
        │    (POST /token)
        ▼
   ┌──────────────┐
   │   Backend    │
   └────┬─────────┘
        │
        │ ✔ Reads refreshToken from cookie
        │ ✔ Verifies it:
        │    - If valid → issue new accessToken
        │    - If invalid/expired → 403 (force re-login)
        ▼
   ┌────────────┐
   │   Client   │
   └────┬───────┘
        │
        │ 5. Stores new accessToken cookie
        │ 6. Retries original request

===== Logout Flow =====
   ┌────────────┐
   │   Client   │
   └────┬───────┘
        │
        │ 7. Logout (DELETE /logout)
        ▼
   ┌──────────────┐
   │   Backend    │
   └────┬─────────┘
        │
        │ ✔ Removes refreshToken from array/db
        │ ✔ Clears both cookies
        ▼
   ┌────────────┐
   │   Client   │
   └────────────┘
        ✔ User fully logged out



  // verifying access token
  // prettier-ignore
  jwt.verify(accessToken,process.env.ACCESS_SECRET_TOKEN,async (err, decoded) => {
      if(!err){
        const userId = Number(decoded.userId)
        const dataGrid = await tryFetchLayout(userId);
        res
            .status(200)
            .json(dataGrid);
            console.log("working")
         return ;
      }
       res.status(401).json({ message: "unauthorized" });

    }
  );
  return;








  // extracting the token
  // const refreshToken = req.cookies.refreshToken;
  // const accessToken = req.cookies.accessToken;
  // if (accessToken == null && refreshToken == null) {
  //   res.sendStatus(401);
  //   return;
  // }

  // // verifying access token
  // jwt.verify(
  //   accessToken,
  //   process.env.ACCESS_SECRET_TOKEN,
  //   async (err, decoded) => {
  //     // failed to veify access token
  //     // -> verifying refresh token
  //     if (err) {
  //       return jwt.verify(
  //         refreshToken,
  //         process.env.REFRESH_SECRET_TOKEN,
  //         (err, decoded) => {
  //           // failed to verify refresh token
  //           if (err) {
  //             return res
  //               .status(403)
  //               .json({ error: "Invalid or expired token" });
  //           }
  //           // refreshToken successfully verified
  //           // generate new accessToken);
  //           const accessToken = generateAccessToken(decoded.userId);
  //           return res
  //             .cookie("accessToken", accessToken, {
  //               httpOnly: true,
  //               secure: false,
  //               sameSite: "strict",
  //               maxAge: 5 * 60 * 1000, // 15 min
  //             })
  //             .status(200)
  //             .json({ valid: true });
  //         }
  //       );
  //     }
  //     return res.status(200).json({ valid: true });
  //   }
  // );

  const idStr = typeof userId === "number" ? userId.toString() : `${userId}`;

  return jwt.sign({ userId: idStr }, secretAccessToken, {
    expiresIn: "300s",
  });
};

const generateRefreshToken = (userId: number | string) => {
  const idStr = typeof userId === "number" ? userId.toString() : `${userId}`;

  return jwt.sign({ userId: idStr }, secretRefreshToken, {
    expiresIn: "15d",
  });
};


session token date:
access: 15minutes
expire: 15d



// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  userId         Int             @id @default(autoincrement())
  username       String          @default("user") @db.VarChar(14)
  email          String          @unique @db.VarChar(254)
  provider       String          @default("local")
  providerId     String?         @unique
  hash           String?         @unique @db.VarChar(64)
  salt           String?         @unique @db.VarChar(64)
  role           String          @default("user")
  // a user can have many weather components
  WeatherLayouts WeatherLayout[]
  RefreshTokens  RefreshToken[]
}

model WeatherLayout {
  userId     Int
  layoutSize String @db.VarChar(14)
  user       User   @relation(fields: [userId], references: [userId], onUpdate: Cascade, onDelete: Cascade)

  WeatherComponents WeatherComponent[]

  @@id([layoutSize, userId])
}

// user 1-many weatherLayout
model WeatherComponent {
  layoutSize String @db.VarChar(14)
  userId     Int

  weatherId String
  dataGrid  Json

  WeatherLayout WeatherLayout @relation(fields: [layoutSize, userId], references: [layoutSize, userId])

  @@id([layoutSize, userId, weatherId])
}

// refresh token database
// refreshToken 1-1 user
model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  user      User     @relation(fields: [userId], references: [userId], onUpdate: Cascade, onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}
