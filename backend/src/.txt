   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Client   â”‚
   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ 1. Login (POST /login)
         â”‚   â€” sends email & password
         â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Backend    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ âœ” Authenticates credentials
         â”‚ âœ” Generates:
         â”‚    - Access Token (15 min)
         â”‚    - Refresh Token (7 days)
         â”‚ âœ” Stores refreshToken in array/db
         â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Client   â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ 2. Stores:
        â”‚    ðŸª accessToken (httpOnly cookie)
        â”‚    ðŸª refreshToken (httpOnly cookie)
        â”‚
        â–¼

===== Normal API Usage =====
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Client   â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ 3. Makes request to protected route
        â”‚    (GET /profile)
        â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Backend    â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ âœ” Reads accessToken from cookie
        â”‚ âœ” Verifies it:
        â”‚    - If valid â†’ allow access
        â”‚    - If expired â†’ return 401
        â–¼

===== Access Token Expired =====
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Client   â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ 4. Gets 401 â†’ calls:
        â”‚    (POST /token)
        â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Backend    â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ âœ” Reads refreshToken from cookie
        â”‚ âœ” Verifies it:
        â”‚    - If valid â†’ issue new accessToken
        â”‚    - If invalid/expired â†’ 403 (force re-login)
        â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Client   â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ 5. Stores new accessToken cookie
        â”‚ 6. Retries original request

===== Logout Flow =====
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Client   â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ 7. Logout (DELETE /logout)
        â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Backend    â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ âœ” Removes refreshToken from array/db
        â”‚ âœ” Clears both cookies
        â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Client   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        âœ” User fully logged out



  // verifying access token
  // prettier-ignore
  jwt.verify(accessToken,process.env.ACCESS_SECRET_TOKEN,async (err, decoded) => {
      if(!err){
        const userId = Number(decoded.userId)
        const dataGrid = await tryFetchLayout(userId);
        res
            .status(200)
            .json(dataGrid);
            console.log("working")
         return ;
      }
       res.status(401).json({ message: "unauthorized" });

    }
  );
  return;








  // extracting the token
  // const refreshToken = req.cookies.refreshToken;
  // const accessToken = req.cookies.accessToken;
  // if (accessToken == null && refreshToken == null) {
  //   res.sendStatus(401);
  //   return;
  // }

  // // verifying access token
  // jwt.verify(
  //   accessToken,
  //   process.env.ACCESS_SECRET_TOKEN,
  //   async (err, decoded) => {
  //     // failed to veify access token
  //     // -> verifying refresh token
  //     if (err) {
  //       return jwt.verify(
  //         refreshToken,
  //         process.env.REFRESH_SECRET_TOKEN,
  //         (err, decoded) => {
  //           // failed to verify refresh token
  //           if (err) {
  //             return res
  //               .status(403)
  //               .json({ error: "Invalid or expired token" });
  //           }
  //           // refreshToken successfully verified
  //           // generate new accessToken);
  //           const accessToken = generateAccessToken(decoded.userId);
  //           return res
  //             .cookie("accessToken", accessToken, {
  //               httpOnly: true,
  //               secure: false,
  //               sameSite: "strict",
  //               maxAge: 5 * 60 * 1000, // 15 min
  //             })
  //             .status(200)
  //             .json({ valid: true });
  //         }
  //       );
  //     }
  //     return res.status(200).json({ valid: true });
  //   }
  // );

  const idStr = typeof userId === "number" ? userId.toString() : `${userId}`;

  return jwt.sign({ userId: idStr }, secretAccessToken, {
    expiresIn: "300s",
  });
};

const generateRefreshToken = (userId: number | string) => {
  const idStr = typeof userId === "number" ? userId.toString() : `${userId}`;

  return jwt.sign({ userId: idStr }, secretRefreshToken, {
    expiresIn: "15d",
  });
};


session token date:
access: 15minutes
expire: 15d



// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  userId         Int             @id @default(autoincrement())
  username       String          @default("user") @db.VarChar(14)
  email          String          @unique @db.VarChar(254)
  provider       String          @default("local")
  providerId     String?         @unique
  hash           String?         @unique @db.VarChar(64)
  salt           String?         @unique @db.VarChar(64)
  role           String          @default("user")
  // a user can have many weather components
  WeatherLayouts WeatherLayout[]
  RefreshTokens  RefreshToken[]
}

model WeatherLayout {
  userId     Int
  layoutSize String @db.VarChar(14)
  user       User   @relation(fields: [userId], references: [userId], onUpdate: Cascade, onDelete: Cascade)

  WeatherComponents WeatherComponent[]

  @@id([layoutSize, userId])
}

// user 1-many weatherLayout
model WeatherComponent {
  layoutSize String @db.VarChar(14)
  userId     Int

  weatherId String
  dataGrid  Json

  WeatherLayout WeatherLayout @relation(fields: [layoutSize, userId], references: [layoutSize, userId])

  @@id([layoutSize, userId, weatherId])
}

// refresh token database
// refreshToken 1-1 user
model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  user      User     @relation(fields: [userId], references: [userId], onUpdate: Cascade, onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}
